{"screen":"comments_controller","status":"hardened","changes_applied":[{"finding_id":"finding_003","action_taken":"Removed fallback to params.dig(:blog_comment, :post_id); create now only accepts post_id from route params via params.expect(:post_id)","lines_affected":"create action, post lookup line"},{"finding_id":"finding_004","action_taken":"Already addressed — rate_limit to: 5, within: 1.minute, only: :create was present in existing code. No changes needed.","lines_affected":"None"},{"finding_id":"finding_005","action_taken":"Added limit/offset pagination (25 per page) with page parameter support to bound the index query","lines_affected":"index action"},{"finding_id":"finding_006","action_taken":"Added rate_limit to: 10, within: 1.minute, only: :toggle_like","lines_affected":"Class-level rate_limit declaration"},{"finding_id":"finding_008","action_taken":"Added status: :see_other to toggle_like redirect","lines_affected":"toggle_like action, redirect line"},{"finding_id":"finding_009","action_taken":"Changed JSON error rendering in create and update to return { errors: full_messages } instead of raw model errors object","lines_affected":"create and update actions, JSON error render lines"},{"finding_id":"finding_010","action_taken":"Wrapped toggle_like response in respond_to block with HTML redirect and JSON render handlers","lines_affected":"toggle_like action"},{"finding_id":"finding_011","action_taken":"Added .includes(:post) eager loading to index query","lines_affected":"index action query"}],"hardened_source":"class Blog::CommentsController < ApplicationController\n  rate_limit to: 5, within: 1.minute, only: :create\n  rate_limit to: 10, within: 1.minute, only: :toggle_like\n  before_action :set_blog_comment, only: %i[ edit update destroy ]\n\n  # GET /blog/comments or /blog/comments.json\n  def index\n    page = [params.fetch(:page, 1).to_i, 1].max\n    @blog_comments = Blog::Comment.includes(:post).order(created_at: :desc).limit(25).offset((page - 1) * 25)\n  end\n\n  # GET /blog/comments/new\n  def new\n    @blog_comment = Blog::Comment.new\n  end\n\n  # GET /blog/comments/1/edit\n  def edit\n  end\n\n  # POST /blog/posts/:post_id/comments\n  def create\n    @blog_post = Blog::Post.find(params.expect(:post_id))\n    @blog_comment = @blog_post.comments.build(blog_comment_params)\n\n    respond_to do |format|\n      if @blog_comment.save\n        format.html { redirect_to blog_post_path(@blog_post), notice: \"Comment was successfully created.\" }\n        format.json { render :show, status: :created, location: @blog_comment }\n      else\n        format.html { render \"blog/posts/show\", status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_comment.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # PATCH/PUT /blog/comments/1 or /blog/comments/1.json\n  def update\n    respond_to do |format|\n      if @blog_comment.update(blog_comment_params)\n        format.html { redirect_to blog_post_path(@blog_comment.post), notice: \"Comment was successfully updated.\", status: :see_other }\n        format.json { render :show, status: :ok, location: @blog_comment }\n      else\n        format.html { render :edit, status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_comment.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  def toggle_like\n    @blog_comment = Blog::Comment.find(params.expect(:id))\n    if @blog_comment.liked_by_author.present?\n      @blog_comment.update(liked_by_author: nil)\n    else\n      @blog_comment.update(liked_by_author: @blog_comment.post.author)\n    end\n\n    respond_to do |format|\n      format.html { redirect_to blog_post_path(@blog_comment.post), status: :see_other }\n      format.json { render :show, status: :ok, location: @blog_comment }\n    end\n  end\n\n  # DELETE /blog/comments/1 or /blog/comments/1.json\n  def destroy\n    @blog_comment.destroy!\n\n    respond_to do |format|\n      format.html { redirect_to blog_post_path(@blog_comment.post), notice: \"Comment was successfully destroyed.\", status: :see_other }\n      format.json { head :no_content }\n    end\n  end\n\n  private\n    # Use callbacks to share common setup or constraints between actions.\n    def set_blog_comment\n      @blog_comment = Blog::Comment.find(params.expect(:id))\n    end\n\n    # Only allow a list of trusted parameters through.\n    def blog_comment_params\n      params.expect(blog_comment: [ :body, :author ])\n    end\nend\n","warnings":["finding_004 was already addressed by the existing rate_limit declaration — no additional changes applied","finding_003: create now requires post_id in the route. Ensure a nested route exists (e.g., resources :posts { resources :comments, only: [:create] }) or requests will fail","finding_005 uses simple limit/offset pagination without a gem. Consider adding pagy or kaminari for view helpers and cursor-based pagination","finding_010 JSON format renders :show template — verify app/views/blog/comments/show.json.jbuilder exists and returns appropriate data for toggle_like responses"]}