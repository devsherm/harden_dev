{"controller":"comments_controller","status":"hardened","changes_applied":[{"finding_id":"finding_001","action_taken":"Added authorize_comment_owner! before_action for edit, update, and destroy that checks @blog_comment.user == current_user, returning 403/redirect if unauthorized","lines_affected":"New before_action declaration + private authorize_comment_owner! method"},{"finding_id":"finding_002","action_taken":"Added authorize_post_author! before_action for toggle_like that restricts liking to the post's author, returning 403/redirect if unauthorized","lines_affected":"New before_action declaration + private authorize_post_author! method"},{"finding_id":"finding_003","action_taken":"Added :toggle_like to the set_blog_comment before_action list and removed the inline Blog::Comment.find from toggle_like","lines_affected":"before_action :set_blog_comment now includes toggle_like; toggle_like body simplified"},{"finding_id":"finding_004","action_taken":"Clamped page parameter to range 1..1000 using .clamp(1, 1000) to prevent unbounded OFFSET queries","lines_affected":"index action page calculation"},{"finding_id":"finding_005","action_taken":"Added rate_limit to: 5, within: 1.minute for both update and destroy actions","lines_affected":"New rate_limit declarations at top of controller"},{"finding_id":"finding_006","action_taken":"Added rate_limit to: 30, within: 1.minute for the index action (higher limit for read-only public endpoint)","lines_affected":"New rate_limit declaration at top of controller"},{"finding_id":"finding_007","action_taken":"Wrapped toggle_like read-then-write in @blog_comment.with_lock to prevent race conditions; update already uses non-bang .update() with error handling","lines_affected":"toggle_like action body wrapped in with_lock block"}],"hardened_source":"class Blog::CommentsController < ApplicationController\n  before_action :require_authentication, except: :index\n  rate_limit to: 30, within: 1.minute, only: :index\n  rate_limit to: 5, within: 1.minute, only: :create\n  rate_limit to: 5, within: 1.minute, only: :update\n  rate_limit to: 5, within: 1.minute, only: :destroy\n  rate_limit to: 10, within: 1.minute, only: :toggle_like\n  before_action :set_blog_comment, only: %i[ edit update destroy toggle_like ]\n  before_action :authorize_comment_owner!, only: %i[ edit update destroy ]\n  before_action :authorize_post_author!, only: :toggle_like\n\n  # GET /blog/comments or /blog/comments.json\n  def index\n    page = params.fetch(:page, 1).to_i.clamp(1, 1000)\n    @blog_comments = Blog::Comment.includes(:post, :user).order(created_at: :desc).limit(25).offset((page - 1) * 25)\n  end\n\n  # GET /blog/comments/new\n  def new\n    @blog_comment = Blog::Comment.new\n  end\n\n  # GET /blog/comments/1/edit\n  def edit\n  end\n\n  # POST /blog/posts/:post_id/comments\n  def create\n    @blog_post = Blog::Post.find(params.expect(:post_id))\n    @blog_comment = @blog_post.comments.build(blog_comment_params)\n    @blog_comment.user = current_user\n\n    respond_to do |format|\n      if @blog_comment.save\n        format.html { redirect_to blog_post_path(@blog_post), notice: \"Comment was successfully created.\" }\n        format.json { render :show, status: :created, location: @blog_comment }\n      else\n        format.html { render \"blog/posts/show\", status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_comment.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # PATCH/PUT /blog/comments/1 or /blog/comments/1.json\n  def update\n    respond_to do |format|\n      if @blog_comment.update(blog_comment_params)\n        format.html { redirect_to blog_post_path(@blog_comment.post), notice: \"Comment was successfully updated.\", status: :see_other }\n        format.json { render :show, status: :ok, location: @blog_comment }\n      else\n        format.html { render :edit, status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_comment.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  def toggle_like\n    @blog_comment.with_lock do\n      new_status = @blog_comment.liked? ? :unset : :liked\n\n      respond_to do |format|\n        if @blog_comment.update(like_status: new_status)\n          format.html { redirect_to blog_post_path(@blog_comment.post), status: :see_other }\n          format.json { render :show, status: :ok, location: @blog_comment }\n        else\n          format.html { redirect_to blog_post_path(@blog_comment.post), alert: \"Could not update like.\", status: :see_other }\n          format.json { render json: { errors: @blog_comment.errors.full_messages }, status: :unprocessable_entity }\n        end\n      end\n    end\n  end\n\n  # DELETE /blog/comments/1 or /blog/comments/1.json\n  def destroy\n    @blog_comment.destroy!\n\n    respond_to do |format|\n      format.html { redirect_to blog_post_path(@blog_comment.post), notice: \"Comment was successfully destroyed.\", status: :see_other }\n      format.json { head :no_content }\n    end\n  end\n\n  private\n    # Use callbacks to share common setup or constraints between actions.\n    def set_blog_comment\n      @blog_comment = Blog::Comment.find(params.expect(:id))\n    end\n\n    def authorize_comment_owner!\n      unless @blog_comment.user == current_user\n        respond_to do |format|\n          format.html { redirect_to blog_post_path(@blog_comment.post), alert: \"Not authorized.\", status: :see_other }\n          format.json { render json: { error: \"Not authorized\" }, status: :forbidden }\n        end\n      end\n    end\n\n    def authorize_post_author!\n      unless @blog_comment.post.user == current_user\n        respond_to do |format|\n          format.html { redirect_to blog_post_path(@blog_comment.post), alert: \"Not authorized.\", status: :see_other }\n          format.json { render json: { error: \"Not authorized\" }, status: :forbidden }\n        end\n      end\n    end\n\n    # Only allow a list of trusted parameters through.\n    def blog_comment_params\n      params.expect(blog_comment: [ :body ])\n    end\nend\n","warnings":["authorize_post_author! assumes Blog::Post belongs_to :user — verify that Post has a user association. If Post uses a string 'author' field instead, adjust the check to match your data model (e.g., @blog_comment.post.author == current_user.name)","No admin/moderator bypass is included in authorize_comment_owner! or authorize_post_author! — if admins should be able to act on any comment, add a role check (e.g., '|| current_user.admin?')","with_lock in toggle_like acquires a database row lock (SELECT FOR UPDATE) — this is correct for preventing race conditions but verify your SQLite configuration supports row-level locking; SQLite uses database-level locks which may slightly increase contention under high concurrency"]}