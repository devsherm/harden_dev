{
  "controller": "comments_controller",
  "status": "analyzed",
  "findings": [
    {
      "id": "finding_001",
      "severity": "medium",
      "category": "other",
      "scope": "controller",
      "action": "toggle_like",
      "summary": "Database row lock held during response rendering",
      "detail": "The `with_lock` block wraps the entire `respond_to` block, including template rendering and redirect generation. The pessimistic lock on the comment row is held far longer than necessary — it should only cover the read-check-update cycle. Under concurrent toggle requests, this creates lock contention on the row and increases the window for lock-wait timeouts, which an attacker could exploit to degrade performance.",
      "suggested_fix": "Narrow the `with_lock` scope to only the read and update. Compute `new_status` and call `update` inside `with_lock`, then call `respond_to` outside it after the lock is released."
    },
    {
      "id": "finding_002",
      "severity": "medium",
      "category": "authorization",
      "scope": "module",
      "action": "create",
      "summary": "No access check on target post before creating comment",
      "detail": "The `create` action finds any `Blog::Post` by ID and attaches a comment to it. There is no verification that the post is in a commentable state (e.g., not locked, archived, or otherwise restricted). Any authenticated user can create comments on any post by submitting an arbitrary `post_id`. If post-level access controls are added later, this becomes an authorization bypass.",
      "suggested_fix": "Add a guard that validates the target post is eligible for new comments — e.g., a `commentable?` check or a scope like `Blog::Post.commentable.find(...)`. Even if no such state exists today, adding a `commentable` scope now makes the controller resilient to future schema changes."
    },
    {
      "id": "finding_003",
      "severity": "low",
      "category": "info_leak",
      "scope": "controller",
      "action": "index",
      "summary": "Public index exposes comments from all posts without scoping",
      "detail": "The `index` action is the only unauthenticated endpoint and returns comments across all posts. If any concept of post visibility (drafts, unlisted, private) is introduced, comments on those posts would leak through this endpoint. Even today, the unscoped query paired with the `includes(:post, :user)` eager load means the JSON/HTML views could expose post titles and user details for every comment.",
      "suggested_fix": "Scope the index query through visible/published posts: `Blog::Comment.joins(:post).where(blog_posts: { ... }).includes(:post, :user)`. At minimum, ensure the view templates do not expose sensitive user attributes (email, etc.) from the eager-loaded `:user` association."
    },
    {
      "id": "finding_004",
      "severity": "low",
      "category": "info_leak",
      "scope": "controller",
      "action": null,
      "summary": "Comment existence enumerable via 403 vs 404 response differentiation",
      "detail": "The `set_blog_comment` callback runs before `authorize_comment_owner!`. When an unauthorized user requests a valid comment ID they get 403 Forbidden; when they request a non-existent ID they get 404 Not Found. This oracle lets an attacker enumerate valid comment IDs and confirm which comments exist, which could be leveraged for further targeted attacks.",
      "suggested_fix": "Return a uniform 404 for both not-found and not-authorized cases on `edit`/`update`/`destroy`, or scope the lookup to `current_user.comments.find(...)` so unauthorized records appear nonexistent."
    },
    {
      "id": "finding_005",
      "severity": "low",
      "category": "other",
      "scope": "controller",
      "action": "destroy",
      "summary": "`destroy!` raises unhandled exception on failure",
      "detail": "`destroy!` raises `ActiveRecord::RecordNotDestroyed` if a `before_destroy` callback halts the chain or a database constraint prevents deletion. In production this surfaces as a 500 Internal Server Error. While Rails suppresses stack traces in production, the generic 500 adds noise to error monitoring and gives no useful feedback to the user.",
      "suggested_fix": "Use `destroy` (without bang) and handle the failure case explicitly, returning an appropriate error response with a user-facing message and correct status code."
    },
    {
      "id": "finding_006",
      "severity": "low",
      "category": "rate_limiting",
      "scope": "controller",
      "action": "index",
      "summary": "High-offset pagination on unauthenticated endpoint enables resource consumption",
      "detail": "The page parameter is clamped to 1–1000, allowing offsets up to 24,975. In SQLite, large OFFSET values require scanning and discarding rows sequentially, making high-page requests significantly more expensive than low-page ones. Combined with the 30 req/min rate limit on the unauthenticated `index` endpoint, an attacker can cause disproportionate database load by repeatedly requesting high page numbers.",
      "suggested_fix": "Switch to cursor-based (keyset) pagination using `created_at`/`id` as the cursor, which has constant-time performance regardless of position. If offset pagination must be retained, lower the page clamp to a realistic ceiling (e.g., 100) or reduce the rate limit for high-page requests."
    },
    {
      "id": "finding_007",
      "severity": "low",
      "category": "rate_limiting",
      "scope": "controller",
      "action": "edit",
      "summary": "No rate limit on `new` and `edit` actions",
      "detail": "The `new` and `edit` actions render forms and are not rate-limited. While both require authentication, `edit` calls `set_blog_comment` which hits the database. An attacker with valid credentials could rapidly request `edit` for many comment IDs to probe comment existence and cause moderate DB load.",
      "suggested_fix": "Add a rate limit to `new` and `edit`, e.g., `rate_limit to: 30, within: 1.minute, only: %i[new edit]`."
    }
  ],
  "overall_risk": "low",
  "notes": "This controller is already well-hardened: authentication is enforced on all mutating actions, ownership authorization is in place for edit/update/destroy, toggle_like is scoped to the post author, strong params are tight (only `:body`), rate limits cover all major actions, and pagination is clamped. The findings above are incremental improvements — the most actionable are narrowing the `with_lock` scope in `toggle_like` (finding_001) and unifying the 403/404 response to prevent ID enumeration (finding_004). The remaining items are low-severity defense-in-depth measures."
}
