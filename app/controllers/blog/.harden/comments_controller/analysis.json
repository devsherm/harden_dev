{"screen":"comments_controller","status":"analyzed","findings":[{"id":"finding_001","severity":"high","category":"authorization","action":null,"summary":"No authorization checks on any action","detail":"The controller has zero authorization. Any anonymous or authenticated user can edit, update, and destroy ANY comment in the system. There is no ownership check (e.g., verifying current_user == comment.author) and no admin/role gating. This applies to all mutating actions: create, update, destroy, and toggle_like.","suggested_fix":"Add an authentication check (e.g., before_action :authenticate_user!) and authorization logic. At minimum, restrict update/destroy to the comment's author or an admin. Consider a policy object or a before_action that verifies ownership."},{"id":"finding_002","severity":"high","category":"authorization","action":"toggle_like","summary":"toggle_like has no authorization and allows unrestricted like manipulation","detail":"Any request with a valid comment ID can toggle the liked_by_author flag. There is no check that the requester is actually the post's author. The action blindly sets liked_by_author to the post's author name, meaning anyone can forge an 'author liked this' status on any comment.","suggested_fix":"Restrict toggle_like to the authenticated post author only. Verify that the current user matches @blog_comment.post.author before allowing the toggle."},{"id":"finding_003","severity":"medium","category":"params","action":"create","summary":"post_id accepted from nested body params enables arbitrary post association","detail":"The create action resolves the parent post via `params[:post_id] || params.dig(:blog_comment, :post_id)`. The fallback to the request body means a user can associate a comment with any arbitrary post by crafting the blog_comment[post_id] parameter, bypassing any routing-level scoping. This is an IDOR (Insecure Direct Object Reference) vector.","suggested_fix":"Only accept post_id from the route parameter (params[:post_id]). Remove the fallback to params.dig(:blog_comment, :post_id). If the nested route is the only entry point, require params.expect(:post_id)."},{"id":"finding_004","severity":"medium","category":"rate_limiting","action":"create","summary":"No rate limiting on comment creation","detail":"The create action has no throttling. An attacker can flood any post with unlimited comments by scripting POST requests. This enables spam, storage exhaustion, and degraded UX.","suggested_fix":"Add rate limiting via Rack::Attack or Rails 8's built-in rate_limit DSL. For example: `rate_limit to: 10, within: 1.minute, only: :create`."},{"id":"finding_005","severity":"medium","category":"other","action":"index","summary":"Unbounded query loads all comments without pagination","detail":"Blog::Comment.all loads every comment in the database. With sufficient volume, this becomes a denial-of-service vector — an attacker can create many comments and then hit the index endpoint to force expensive queries and large memory allocations.","suggested_fix":"Add pagination (e.g., using pagy or kaminari) or at minimum a .limit() clause. Consider whether the public index endpoint is even needed — comments are typically shown per-post, not globally."},{"id":"finding_006","severity":"medium","category":"other","action":"index","summary":"No scoping — index exposes all comments across all posts","detail":"The index action returns every comment in the system regardless of which post they belong to. This may leak comments from draft/unpublished posts or expose data that should be contextual to a specific post.","suggested_fix":"Scope the index to a specific post (e.g., @post.comments) or remove the action entirely if comments should only be viewed in the context of their parent post."},{"id":"finding_007","severity":"medium","category":"validation","action":"toggle_like","summary":"toggle_like bypasses strong params and has no validation guard","detail":"The toggle_like action calls update() directly without going through strong parameters or any validation. While the value is derived server-side (post.author), the pattern of direct attribute updates outside strong params is fragile — future changes could introduce mass-assignment risk. Additionally, update() skips the respond_to block, returning no JSON response for API consumers.","suggested_fix":"Consider using a dedicated method or at minimum wrap in a respond_to block. Add a guard clause to ensure the comment and post exist and the operation is valid."},{"id":"finding_008","severity":"low","category":"redirect","action":"toggle_like","summary":"toggle_like redirect uses default 302 instead of 303 for state-changing action","detail":"After mutating state, toggle_like issues a redirect_to without specifying status: :see_other (303). Per HTTP semantics (and Rails convention for Turbo), state-changing POST/PATCH actions should redirect with 303 to prevent resubmission. The other mutating actions correctly use :see_other.","suggested_fix":"Add `status: :see_other` to the redirect_to in toggle_like, consistent with the destroy and update actions."},{"id":"finding_009","severity":"low","category":"other","action":"toggle_like","summary":"toggle_like not included in before_action :set_blog_comment","detail":"toggle_like duplicates the find logic from set_blog_comment with its own Blog::Comment.find call. This is inconsistent and means any future changes to set_blog_comment (e.g., adding scoping or authorization) won't apply to toggle_like.","suggested_fix":"Add :toggle_like to the before_action :set_blog_comment list and remove the redundant find call from the action body."},{"id":"finding_010","severity":"low","category":"info_leak","action":"create","summary":"JSON error responses expose model validation structure","detail":"The create and update actions render @blog_comment.errors as JSON on failure. While standard in Rails, this reveals attribute names and validation rules to API consumers, which can aid attackers in understanding the data model.","suggested_fix":"For public-facing APIs, consider returning generic error messages or a curated subset of errors rather than the raw ActiveModel::Errors hash."}],"overall_risk":"high","notes":"The most critical gap is the complete absence of authentication and authorization — every action is open to any requester. The controller also has an IDOR vector via the post_id fallback in create, and the toggle_like action is particularly exposed since it mutates state with no access control. Once auth is in place, add rate limiting on create and toggle_like, scope the index, and add pagination. The strong params and CSRF handling are otherwise reasonable for a standard Rails scaffold."}