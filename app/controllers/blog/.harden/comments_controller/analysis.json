{"screen":"comments_controller","status":"analyzed","findings":[{"id":"finding_001","severity":"high","category":"authorization","scope":"app","action":null,"summary":"No authentication or authorization on any action","detail":"The controller has no authentication checks (e.g., before_action :authenticate_user!) and no authorization checks. Any anonymous user can create, edit, update, and delete any comment in the system. The edit, update, and destroy actions use set_blog_comment which finds by ID without scoping to the current user, meaning any user can modify or delete any other user's comments.","suggested_fix":"Add authentication (e.g., Devise, Rails 8 built-in authentication) and authorization (e.g., Pundit, Action Policy, or manual current_user ownership checks). Scope mutations to the current user: current_user.comments.find(params[:id]) or verify ownership after find."},{"id":"finding_002","severity":"high","category":"authorization","scope":"controller","action":"toggle_like","summary":"toggle_like has no authorization and is not in before_action list","detail":"The toggle_like action finds any comment by ID and toggles its liked_by_author field without verifying the requester is the post author. Anyone can like/unlike any comment. Additionally, it is excluded from the before_action :set_blog_comment callback, duplicating the find logic inconsistently.","suggested_fix":"Add toggle_like to the before_action :set_blog_comment list. Add an authorization check ensuring only the post's author can toggle likes. Consider using a dedicated policy or guard clause."},{"id":"finding_003","severity":"medium","category":"params","scope":"controller","action":"create","summary":"Unvalidated post_id allows comment association with arbitrary posts","detail":"The create action accepts post_id from either params[:post_id] (route param) or params.dig(:blog_comment, :post_id) (form body) without strong parameter filtering. An attacker can POST a comment to any post by manipulating the post_id value, even if the UI only shows a form scoped to a specific post. The fallback to the nested param means the route-level scoping can be bypassed entirely.","suggested_fix":"Only accept post_id from the route (params[:post_id]) via a nested resource route (e.g., resources :posts { resources :comments, only: [:create] }). Remove the fallback to params.dig(:blog_comment, :post_id). If the flat route is needed, require post_id through strong params and verify the user has permission to comment on that post."},{"id":"finding_004","severity":"medium","category":"rate_limiting","scope":"controller","action":"create","summary":"No rate limiting on comment creation","detail":"The create action has no rate limiting, allowing an attacker to flood the application with spam comments. This is especially dangerous given the lack of authentication — an anonymous user can submit unlimited comments.","suggested_fix":"Add rate limiting using Rails 8's built-in rate_limit macro (e.g., rate_limit to: 10, within: 1.minute, only: :create) or Rack::Attack middleware. Combine with CAPTCHA or honeypot fields for anonymous submissions."},{"id":"finding_005","severity":"medium","category":"other","scope":"controller","action":"index","summary":"Unbounded query returns all comments without pagination or scoping","detail":"Blog::Comment.all loads every comment in the database with no pagination, scoping, or limit. This is both a performance issue (memory exhaustion with large datasets) and a potential information disclosure issue (exposes all comments across all posts, including potentially private or draft posts). An attacker could use this endpoint to scrape all comment data.","suggested_fix":"Add pagination (e.g., pagy, kaminari, or cursor-based). Scope comments to published/visible posts. Consider whether a global comment index is needed at all — comments are typically viewed in the context of their parent post."},{"id":"finding_006","severity":"medium","category":"rate_limiting","scope":"controller","action":"toggle_like","summary":"No rate limiting on toggle_like allows rapid state toggling","detail":"The toggle_like action can be called repeatedly without rate limiting, creating unnecessary database writes and potential for abuse. Combined with the lack of authentication, this could be used for a write-amplification attack against the database.","suggested_fix":"Add rate limiting to toggle_like. Consider using an idempotent approach (explicit like/unlike actions with desired state) rather than a toggle to prevent race conditions."},{"id":"finding_007","severity":"medium","category":"validation","scope":"module","action":"create","summary":"No visible content validation on comment body","detail":"The controller permits the :body parameter but there is no indication of length validation, content sanitization, or blank-check at the controller level. While model validations may exist, defense in depth suggests ensuring extremely long bodies (potential DoS via storage/rendering) and empty bodies are rejected. Without model inspection this is flagged as a potential gap.","suggested_fix":"Ensure the Blog::Comment model validates presence and maximum length of :body (e.g., validates :body, presence: true, length: { maximum: 10_000 }). Consider content sanitization if raw HTML is rendered."},{"id":"finding_008","severity":"low","category":"other","scope":"controller","action":"toggle_like","summary":"toggle_like redirect missing status: :see_other","detail":"All other state-changing actions (update, destroy) use status: :see_other (303) on redirect, which is correct for POST/PATCH/DELETE to prevent resubmission on browser back/refresh. The toggle_like action omits this, defaulting to 302, which may cause the browser to resubmit the POST on back navigation.","suggested_fix":"Add status: :see_other to the redirect_to call in toggle_like for consistency and correctness."},{"id":"finding_009","severity":"low","category":"info_leak","scope":"controller","action":"create","summary":"JSON error responses may expose model internals","detail":"The create and update actions render @blog_comment.errors as JSON on validation failure. While standard Rails practice, this can reveal attribute names, validation rules, and internal schema details to API consumers. In the absence of authentication, this information is available to anyone.","suggested_fix":"Consider using a serializer or error formatter that only exposes user-facing messages without attribute metadata. At minimum, ensure no sensitive attributes are included in error output."},{"id":"finding_010","severity":"low","category":"other","scope":"controller","action":"toggle_like","summary":"toggle_like lacks respond_to block for format handling","detail":"Unlike all other actions, toggle_like only handles HTML format (redirect). A JSON or other format request will either error or produce an unexpected response. This inconsistency could be exploited to trigger unhandled exceptions that reveal stack traces in development mode.","suggested_fix":"Add a respond_to block to toggle_like handling both HTML (redirect) and JSON (render updated comment) formats, consistent with other actions."},{"id":"finding_011","severity":"low","category":"other","scope":"controller","action":"index","summary":"Potential N+1 query in index if views access associations","detail":"Blog::Comment.all does not eager-load associations. If the index view or JSON template accesses comment.post (e.g., to display the parent post title), this will generate an N+1 query. While primarily a performance issue, slow queries from N+1 patterns can be exploited for denial of service.","suggested_fix":"Add eager loading: Blog::Comment.includes(:post).all, or scope to a specific post via nested routing."}],"overall_risk":"high","notes":"The most critical issue is the complete absence of authentication and authorization — every action is open to anonymous users with no ownership checks. The controller also has an inconsistent pattern where toggle_like is not covered by the before_action callback and lacks the respond_to/status conventions used by other actions. The unbounded index query and missing rate limiting compound the risk. Hardening priority should be: (1) add authentication, (2) add authorization/ownership scoping, (3) add rate limiting, (4) add pagination, (5) fix toggle_like inconsistencies."}