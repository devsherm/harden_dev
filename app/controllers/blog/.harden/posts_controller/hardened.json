{
  "controller": "posts_controller",
  "status": "hardened",
  "changes_applied": [
    {
      "finding_id": "finding_001",
      "action_taken": "Capped pagination page parameter to 0..400 range using clamp, limiting maximum offset to 10,000 rows",
      "lines_affected": "pagination_offset private method"
    },
    {
      "finding_id": "finding_002",
      "action_taken": "Added rate_limit to: 60, within: 1.minute for index and show actions to throttle automated scraping while allowing normal browsing",
      "lines_affected": "rate_limit declarations at top of class"
    },
    {
      "finding_id": "finding_003",
      "action_taken": "Replaced full_messages with sanitized error output that reports which fields are invalid without exposing internal validation rule details or attribute naming conventions",
      "lines_affected": "JSON error responses in create and update actions"
    },
    {
      "finding_id": "finding_004",
      "action_taken": "Skipped — topic is already a string-backed enum on Blog::Post (per commit b5991ac), which provides model-layer inclusion validation automatically. No controller change needed.",
      "lines_affected": "None"
    },
    {
      "finding_id": "finding_005",
      "action_taken": "Addressed by finding_001's page cap. Added code comment documenting keyset pagination as the recommended upgrade path for larger datasets.",
      "lines_affected": "pagination_offset private method (comment)"
    }
  ],
  "hardened_source": "class Blog::PostsController < ApplicationController\n  before_action :require_authentication, except: %i[ index show ]\n  before_action :set_blog_post, only: %i[ show edit update destroy ]\n  before_action :authorize_post_owner!, only: %i[ edit update destroy ]\n\n  rate_limit to: 60, within: 1.minute, only: %i[ index show ]\n  rate_limit to: 5, within: 1.minute, only: %i[ create update ]\n  rate_limit to: 3, within: 1.minute, only: :destroy\n\n  # GET /blog/posts or /blog/posts.json\n  def index\n    @blog_posts = Blog::Post.includes(:user).order(created_at: :desc).limit(25).offset(pagination_offset)\n  end\n\n  # GET /blog/posts/1 or /blog/posts/1.json\n  def show\n    @blog_comment = Blog::Comment.new(post: @blog_post)\n  end\n\n  # GET /blog/posts/new\n  def new\n    @blog_post = Blog::Post.new\n  end\n\n  # GET /blog/posts/1/edit\n  def edit\n  end\n\n  # POST /blog/posts or /blog/posts.json\n  def create\n    @blog_post = Blog::Post.new(blog_post_params)\n    @blog_post.user = current_user\n\n    respond_to do |format|\n      if @blog_post.save\n        format.html { redirect_to @blog_post, notice: \"Post was successfully created.\" }\n        format.json { render :show, status: :created, location: @blog_post }\n      else\n        format.html { render :new, status: :unprocessable_entity }\n        format.json { render json: { errors: sanitized_errors(@blog_post) }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # PATCH/PUT /blog/posts/1 or /blog/posts/1.json\n  def update\n    respond_to do |format|\n      if @blog_post.update(blog_post_params)\n        format.html { redirect_to @blog_post, notice: \"Post was successfully updated.\", status: :see_other }\n        format.json { render :show, status: :ok, location: @blog_post }\n      else\n        format.html { render :edit, status: :unprocessable_entity }\n        format.json { render json: { errors: sanitized_errors(@blog_post) }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # DELETE /blog/posts/1 or /blog/posts/1.json\n  def destroy\n    if @blog_post.destroy\n      respond_to do |format|\n        format.html { redirect_to blog_posts_path, notice: \"Post was successfully destroyed.\", status: :see_other }\n        format.json { head :no_content }\n      end\n    else\n      respond_to do |format|\n        format.html { redirect_to @blog_post, alert: \"Post could not be destroyed.\", status: :see_other }\n        format.json { render json: { error: \"Post could not be destroyed.\" }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  private\n    # Use callbacks to share common setup or constraints between actions.\n    def set_blog_post\n      @blog_post = Blog::Post.includes(:user).find(params.expect(:id))\n    end\n\n    # Verify the current user owns the post before allowing mutations.\n    def authorize_post_owner!\n      unless @blog_post.user_id == current_user.id\n        respond_to do |format|\n          format.html { redirect_to @blog_post, alert: \"You are not authorized to perform this action.\", status: :see_other }\n          format.json { render json: { error: \"Forbidden\" }, status: :forbidden }\n        end\n      end\n    end\n\n    # Only allow a list of trusted parameters through.\n    def blog_post_params\n      params.expect(blog_post: [ :title, :body, :topic ])\n    end\n\n    # Cap page depth to prevent large-OFFSET DoS against the database.\n    # For larger datasets, consider keyset pagination (WHERE created_at < :cursor)\n    # which performs in constant time regardless of page depth.\n    def pagination_offset\n      params.fetch(:page, 0).to_i.clamp(0, 400) * 25\n    end\n\n    # Map model errors to user-friendly messages without exposing internal\n    # attribute names, validation rules, or schema details.\n    def sanitized_errors(record)\n      record.errors.map do |error|\n        error.attribute.to_s.humanize\n      end.uniq.map { |field| \"#{field} is invalid\" }\n    end\nend\n",
  "warnings": [
    "finding_004 (topic validation): No change applied — Blog::Post already uses a string-backed enum for topic (commit b5991ac), which enforces inclusion at the model layer. Verify this matches your expectations.",
    "finding_003 (sanitized errors): The sanitized_errors helper now returns generic messages like 'Title is invalid' instead of specific messages like 'Title is too long (maximum is 255 characters)'. If your frontend or API consumers rely on specific validation messages for field-level error display, you may want to restore full_messages for authenticated/first-party clients and only sanitize for public-facing responses.",
    "finding_002 (read rate limit): The 60 req/min limit on index/show is a reasonable default. Adjust upward if legitimate users browse rapidly or if the app is behind a CDN that collapses requests."
  ]
}
