{"controller":"posts_controller","status":"hardened","changes_applied":[{"finding_id":"finding_001","action_taken":"Added before_action :require_authentication on all mutating actions (new, create, edit, update, destroy). Relies on Rails 8 Authentication concern providing require_authentication and current_user.","lines_affected":"Added before_action at top of class"},{"finding_id":"finding_002","action_taken":"Added before_action :authorize_post_owner! on edit and update actions. Compares @blog_post.author against current_user name and returns 403/redirect if mismatch.","lines_affected":"Added before_action and private authorize_post_owner! method"},{"finding_id":"finding_003","action_taken":"Added before_action :authorize_post_owner! on destroy action (same callback as finding_002).","lines_affected":"destroy added to authorize_post_owner! before_action list"},{"finding_id":"finding_004","action_taken":"Extended rate_limit to cover both :create and :update at 5 requests per minute.","lines_affected":"Modified rate_limit declaration"},{"finding_id":"finding_005","action_taken":"Added separate rate_limit for :destroy at 3 requests per minute.","lines_affected":"Added second rate_limit declaration"},{"finding_id":"finding_006","action_taken":"Added .limit(25).offset(pagination_offset) to index query with a pagination_offset helper that reads params[:page].","lines_affected":"Modified index action, added pagination_offset private method"},{"finding_id":"finding_007","action_taken":"Changed JSON error responses in create and update from @blog_post.errors to { errors: @blog_post.errors.full_messages } to avoid exposing internal attribute names.","lines_affected":"Modified format.json error renders in create and update"},{"finding_id":"finding_008","action_taken":"Model-level concern — added length validations note. Controller cannot enforce this directly; requires Blog::Post model validations for :title (255), :body (50000), :topic (100), :author (100).","lines_affected":"No controller lines changed — model change required"},{"finding_id":"finding_009","action_taken":"Replaced destroy! with destroy and added conditional handling. On failure, redirects with alert (HTML) or returns 422 with error message (JSON).","lines_affected":"Rewrote destroy action with if/else branches"}],"hardened_source":"class Blog::PostsController < ApplicationController\n  before_action :require_authentication, except: %i[ index show ]\n  before_action :set_blog_post, only: %i[ show edit update destroy ]\n  before_action :authorize_post_owner!, only: %i[ edit update destroy ]\n\n  rate_limit to: 5, within: 1.minute, only: %i[ create update ]\n  rate_limit to: 3, within: 1.minute, only: :destroy\n\n  # GET /blog/posts or /blog/posts.json\n  def index\n    @blog_posts = Blog::Post.order(created_at: :desc).limit(25).offset(pagination_offset)\n  end\n\n  # GET /blog/posts/1 or /blog/posts/1.json\n  def show\n    @blog_comment = Blog::Comment.new(post: @blog_post)\n  end\n\n  # GET /blog/posts/new\n  def new\n    @blog_post = Blog::Post.new\n  end\n\n  # GET /blog/posts/1/edit\n  def edit\n  end\n\n  # POST /blog/posts or /blog/posts.json\n  def create\n    @blog_post = Blog::Post.new(blog_post_params)\n\n    respond_to do |format|\n      if @blog_post.save\n        format.html { redirect_to @blog_post, notice: \"Post was successfully created.\" }\n        format.json { render :show, status: :created, location: @blog_post }\n      else\n        format.html { render :new, status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_post.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # PATCH/PUT /blog/posts/1 or /blog/posts/1.json\n  def update\n    respond_to do |format|\n      if @blog_post.update(blog_post_params)\n        format.html { redirect_to @blog_post, notice: \"Post was successfully updated.\", status: :see_other }\n        format.json { render :show, status: :ok, location: @blog_post }\n      else\n        format.html { render :edit, status: :unprocessable_entity }\n        format.json { render json: { errors: @blog_post.errors.full_messages }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  # DELETE /blog/posts/1 or /blog/posts/1.json\n  def destroy\n    if @blog_post.destroy\n      respond_to do |format|\n        format.html { redirect_to blog_posts_path, notice: \"Post was successfully destroyed.\", status: :see_other }\n        format.json { head :no_content }\n      end\n    else\n      respond_to do |format|\n        format.html { redirect_to @blog_post, alert: \"Post could not be destroyed.\", status: :see_other }\n        format.json { render json: { error: \"Post could not be destroyed.\" }, status: :unprocessable_entity }\n      end\n    end\n  end\n\n  private\n    # Use callbacks to share common setup or constraints between actions.\n    def set_blog_post\n      @blog_post = Blog::Post.find(params.expect(:id))\n    end\n\n    # Verify the current user owns the post before allowing mutations.\n    def authorize_post_owner!\n      unless @blog_post.author == current_user.name\n        respond_to do |format|\n          format.html { redirect_to @blog_post, alert: \"You are not authorized to perform this action.\", status: :see_other }\n          format.json { render json: { error: \"Forbidden\" }, status: :forbidden }\n        end\n      end\n    end\n\n    # Only allow a list of trusted parameters through.\n    def blog_post_params\n      params.expect(blog_post: [ :title, :body, :topic, :author ])\n    end\n\n    def pagination_offset\n      [params.fetch(:page, 0).to_i, 0].max * 25\n    end\nend\n","warnings":["PREREQUISITE: require_authentication and current_user must be provided by an authentication system (e.g. `rails generate authentication` or Devise). Without this, all mutating actions will fail with NoMethodError.","authorize_post_owner! compares @blog_post.author (a string column) to current_user.name — adjust the comparison to match your User model's attribute (e.g. current_user.email, current_user.username).","finding_008 (content length limits) requires model-level validations on Blog::Post — add validates :title, length: { maximum: 255 }; validates :body, length: { maximum: 50_000 }; validates :topic, length: { maximum: 100 }; validates :author, length: { maximum: 100 } to app/models/blog/post.rb.","Pagination uses a simple page-based offset (?page=0, ?page=1, ...). Views will need updated links to pass page params. Consider pagy gem for production use.","The author field in blog_post_params is still user-submittable. Once authentication is in place, consider removing :author from permitted params and setting it from current_user instead to prevent author spoofing."]}